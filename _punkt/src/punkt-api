#!/bin/bash

# Copyright 2023 Philipp Seifer
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Enable 'strict' mode.
# See also http://redsymbol.net/articles/unofficial-bash-strict-mode/
#      and https://disconnected.systems/blog/another-bash-strict-mode/
set -euo pipefail
trap 'echo >&2 "Error - exited with status ${?} at line ${LINENO}."' ERR
IFS=$'\n\t'

# --- The following functions are exported as part of the
# --- punkt utility API for writing custom install.punkt scripts.

# Detect the operating system.
punkt_os()
{
    uname -s
}
export -f punkt_os

# Detect distribution (not very useful on macos).
punkt_distr()
{
    local punkt_distr_u

    if [ -f /etc/os-release ]; then
        . /etc/os-release
        punkt_distr_u="${NAME}"
    elif type lsb_release >/dev/null 2>&1; then
        punkt_distr_u=$(lsb_release -si)
    elif [ -f /etc/lsb-release ]; then
        . /etc/lsb-release
        punkt_distr_u="${DISTRIB_ID}"
    else
        punkt_distr_u=$(uname -s)
    fi

    if [[ "${punkt_distr_u}" = "darwin" ]]; then
        echo "macOS"
    else
        echo "${punkt_distr_u}"
    fi
}
export -f punkt_distr

# Detect the available package manager.
punkt_pack()
{
    local pack="echo"
    local i
    local managers=(
        "apk"       # Alpine
        "apt"       # Debian/Ubuntu
        "brew"      # macOS
        "dnf"       # RHEL
        "guix"      # Guix
        "opkg"      # OpenWrt/LEDE
        "pacman"    # Arch Linux
        "pkg"       # FreeBSD
        "pkgin"     # MINIX/NetBSD
        "pkg_add"   # OpenBSD
        "pkgman"    # Haiku
        "xbps"      # void
        "yum"       # CentOS/RHEL/Fedora
        "zypper"    # openSUSE
    )

    for i in "${managers[@]}"; do
        if command -v "$i" &> /dev/null ; then
            [[ "${pack}" = "echo" ]] && pack="${i}"
        fi
    done
    echo "${pack}"
}
export -f punkt_pack

# Print information with highlighting.
punkt_inform()
{
    echo -e -n "\e[32m~punkt~\e[39m" "${@}" "\n"
}
export -f punkt_inform

# Prompt user for y/N.
punkt_prompt()
{
    local prompt="${1:-}"
    local response
    echo -e -n "\e[32m?punkt?\e[39m ${prompt}? [y/N] "
    read -r response
    case "${response}" in
        [yY][eE][sS]|[yY])
            true
            ;;
        *)
            false
            ;;
    esac
}
export -f punkt_prompt

# Test for operating system kernel (uname -s).
punkt_os_is()
{
    local os=${1:-}
    local real_os
    real_os=$(punkt_os)
    [[ "${real_os,,}" = "${os,,}" ]]
}
export -f punkt_os_is

# Test for distribution name.
punkt_distr_is()
{
    local distr=${1:-}
    local real_distr
    real_distr=$(punkt_distr)
    [[ "${real_distr,,}" = "${distr,,}" ]]
}
export -f punkt_distr_is

# Test for package manager.
punkt_pack_is()
{
    local pack=${1:-}
    local real_pack
    real_pack=$(punkt_pack)
    [[ "${real_pack,,}" = "${pack,,}" ]]
}
export -f punkt_pack_is

# Test if some command exists.
punkt_has()
{
    local cmd=${1:?}
    command -v "${cmd}" &> /dev/null
}
export -f punkt_has

# Install package(s) with the appropriate package manager.
punkt_pack_install()
{
    local pks=("${@:?}")
    local pack
    pack=$(punkt_pack)

    punkt_inform "About to install:" "${pks[@]}"
    case "${pack}" in
      "apk") sudo apk add "${pks[@]}" ;;
      "apt") sudo apt install "${pks[@]}" ;;
      "brew") brew install "${pks[@]}" ;;
      "dnf") sudo dnf install "${pks[@]}" ;;
      "guix") sudo guix install "${pks[@]}" ;;
      "opkg") sudo opkg install "${pks[@]}" ;;
      "pkg") sudo pkg update && sudo pkg install --no-repo-update "${pks[@]}" ;;
      "pkg_add") sudo pkg_add "${pks[@]}" ;;
      "pkgin") sudo pkgin install "${pks[@]}" ;;
      "pkgman") sudo pkgman install "${pks[@]}" ;;
      "pacman") sudo pacman -S "${pks[@]}" ;;
      "xbps") sudo xbps-install "${pks[@]}" ;;
      "yum") sudo yum install "${pks[@]}" ;;
      "zypper") sudo zypper install "${pks[@]}" ;;
      *) punkt_inform "No appropriate package manager. Please install: " "${pks[@]}" 
         return 1
         ;;
    esac
}
export -f punkt_pack_install

# Update system with the appropriate package manager. 
punkt_pack_update()
{
    case "$(punkt_pack)" in
      "apk") sudo apk update && sudo apk upgrade ;;
      "apt") sudo apt update && sudo apt upgrade ;;
      "brew") brew update && brew upgrade && brew cleanup ;;
      "dnf") sudo dnf upgrade ;;
      "guix") sudo guix package --upgrade ;;
      "opkg") opkg list-upgradable | cut -f 1 -d ' ' | xargs -r opkg upgrade ;;
      "pkg") sudo pkg update && sudo pkg upgrade --no-repo-update  ;;
      "pkg_add") sudo pkg_add -u ;;
      "pkgin") sudo pkgin update && sudo pkgin upgrade ;;
      "pkgman") sudo pkgman update ;;
      "pacman") sudo pacman -Syu ;;
      "xbps") sudo xbps-install -Sy ;;
      "yum") sudo yum update ;;
      "zypper") sudo zypper up ;;
      *) 
        echo "Unknown package manager. Can not update." 
        return 1
        ;;
    esac
}
export -f punkt_pack_update

# Require a command to exists, try to install.
punkt_require()
{
    local cmd=${1:?}
    if ! command -v "${cmd}" &> /dev/null ; then  
        if punkt_prompt "Failing requirement: ${cmd} - Should punkt try to install it"; then
            punkt_pack_install "${cmd}"
        else
            return 1
        fi
    fi
}
export -f punkt_require

# Curl and untar to PUNKT_STORAGE.
punkt_curl_tar()
{
    punkt_require "curl"
    punkt_require "tar"
    local source="${1:?}"
    curl -s -L "${source}" | tar xvz -C "${PUNKT_STORAGE}"
}
export -f punkt_curl_tar

# Curl and gzip. Needs destination.
punkt_curl_gzip()
{
    punkt_require "curl"
    punkt_require "gzip"
    local source="${1:?}"
    local target="${2:?}"
    curl -fL "${source}" | gzip -d > "${PUNKT_STORAGE}/${target}"
}
export -f punkt_curl_gzip

# Curl and run with bash.
punkt_curl_bash()
{
    punkt_require "curl"
    local source="${1:?}"
    curl -sS "${source}" | bash
}
export -f punkt_curl_bash

# Git clone.
punkt_git()
{
    punkt_require "git"
    local source="${1:?}"
    pushd "${PUNKT_STORAGE}"
	git clone --depth=1 "${source}" 
    popd
}
export -f punkt_git

# Create a link from a directory/file managed by punkt to punkts bin (or an absolute path).
punkt_ln()
{
    local target="${1:?}"
    local link="${2:?}"

    if [[ "${link}" = /* ]]; then
        # For absolute paths, do not prepend "$PUNKT_BIN".
        if [[ ! -e "${link}" || -L "${link}" ]]; then
            ln -sf "${PUNKT_STORAGE}/${target}" "${link}"
        fi
    else
        # For relative paths, prepend "$PUNKT_BIN".
        if [[ ! -f "${PUNKT_BIN}/${link}" || -L "${PUNKT_BIN}/${link}" ]]; then
            ln -sf "${PUNKT_STORAGE}/${target}" "${PUNKT_BIN}/${link}"
        fi
    fi
}
export -f punkt_ln

# Remove a link from a directory/file managed by punkt to punkts bin (or an absolute path).
punkt_unln()
{
    local target="${1:?}"
    local link="${2:?}"

    if [[ "${link}" = /* ]]; then
        # For absolute paths, do not prepend "$PUNKT_BIN".
        if [[ -L "${link}" ]]; then
            rm "${link}"
        fi
    else
        # For relative paths, prepend "$PUNKT_BIN".
        if [[ -L "${PUNKT_BIN}/${link}" ]]; then
            rm "${PUNKT_BIN}/${link}"
        fi
    fi
}
export -f punkt_unln

# Delete a directory (or file) managed by punkt.
punkt_rm()
{
    local file="${1:?}"
    if [[ -n "${file}" && -d "${PUNKT_STORAGE}/${file}" ]]; then
        rm -r "${PUNKT_STORAGE:?}/${file:?}"
    elif [[ -n "${file}" && -f "${PUNKT_STORAGE}/${file}" ]]; then
        rm "${PUNKT_STORAGE:?}/${file:?}"
    fi
}
export -f punkt_rm

